<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>가위바위보 시뮬레이션</title>
<style>
  html,body { height:100%; margin:0; font-family: "Malgun Gothic","Apple SD Gothic Neo","Nanum Gothic", sans-serif; background:#f5f5f5; }
  .wrap { display:flex; flex-direction:column; align-items:center; padding:12px; }
  h1 { margin:6px 0 12px; font-size:20px; color:#222; }
  canvas { background: rgb(200,185,225); border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  .hint { margin-top:10px; color:#333; font-size:13px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>가위바위보 시뮬레이션 (브라우저)</h1>
    <canvas id="c" width="900" height="700"></canvas>
  </div>

<script>
/* -----------------------
   설정
   ----------------------- */
const CANVAS = document.getElementById('c');
const ctx = CANVAS.getContext('2d');
const WIDTH = CANVAS.width, HEIGHT = CANVAS.height;
const FPS = 30;
const BG = [200,185,225]; // 배경색 (원하시면 변경)
const SPRITE_SIZE = 26;   // 조각 크기: 40의 2/3 ~ 26
const INITIAL_COUNT = { "가위":20, "바위":20, "보":20 };

/* 이미지 파일 경로 (같은 폴더) */
const IMAGE_FILES = { "가위":"scissors.png", "바위":"rock.png", "보":"paper.png" };

/* -----------------------
   유틸: 이미지 로드 + 색칠(tint) + 마스크 생성
   ----------------------- */
function loadImage(src){ return new Promise((res, rej)=>{
  const img = new Image();
  img.onload = ()=>res(img);
  img.onerror = (e)=>rej(e);
  img.src = src;
});}

// tint: 이미지 알파 보존하면서 색으로 채우기 (offscreen canvas)
function tintImage(img, colorStr, size){
  const oc = document.createElement('canvas');
  oc.width = size; oc.height = size;
  const octx = oc.getContext('2d');
  octx.clearRect(0,0,size,size);
  octx.drawImage(img, 0, 0, size, size);
  // source-in 기법: 기존 알파 영역 보존하고 색 채움
  octx.globalCompositeOperation = 'source-in';
  octx.fillStyle = colorStr;
  octx.fillRect(0,0,size,size);
  octx.globalCompositeOperation = 'source-over';
  return oc;
}

// mask: Uint8Array of 0/1 by pixel alpha threshold
function makeMask(canvas){
  const w = canvas.width, h = canvas.height;
  const data = canvas.getContext('2d').getImageData(0,0,w,h).data;
  const mask = new Uint8Array(w*h);
  for(let i=0, p=0;i<w*h;i++, p+=4){
    mask[i] = data[p+3] > 128 ? 1 : 0; // alpha threshold
  }
  return {mask, w, h};
}

/* -----------------------
   시뮬 데이터
   ----------------------- */
const COLORS = {
  "가위": 'rgb(255,100,100)',
  "바위": 'rgb(100,255,100)',
  "보":   'rgb(100,100,255)'
};

let IMAGES_CANVAS = {}; // kind -> canvas (tinted & scaled)
let MASKS = {};         // kind -> {mask,w,h}

/* -----------------------
   Piece 클래스 (JS 버전)
   ----------------------- */
class Piece {
  constructor(kind){
    this.kind = kind;
    this.x = Math.random()*(WIDTH-40)+20;
    this.y = Math.random()*(HEIGHT-40)+20;
    this.dx = [ -4, -2, 2, 4 ][Math.floor(Math.random()*4)];
    this.dy = [ -4, -2, 2, 4 ][Math.floor(Math.random()*4)];
    this.updateImage();
  }
  updateImage(){
    this.imgCanvas = IMAGES_CANVAS[this.kind];
    const m = MASKS[this.kind];
    this.mask = m.mask;
    this.w = m.w; this.h = m.h;
    this.rectLeft = () => Math.round(this.x - this.w/2);
    this.rectTop = () => Math.round(this.y - this.h/2);
    this.radius = Math.max(this.w,this.h)/2 * 0.9;
  }
  move(){
    this.x += this.dx; this.y += this.dy;
    if(this.x - this.w/2 < 0){ this.x = this.w/2; this.dx *= -1; }
    if(this.x + this.w/2 > WIDTH){ this.x = WIDTH - this.w/2; this.dx *= -1; }
    if(this.y - this.h/2 < 0){ this.y = this.h/2; this.dy *= -1; }
    if(this.y + this.h/2 > HEIGHT){ this.y = HEIGHT - this.h/2; this.dy *= -1; }
  }
  draw(ctx){
    ctx.drawImage(this.imgCanvas, this.rectLeft(), this.rectTop());
  }
}

/* -----------------------
   충돌: broad-phase(원) + narrow-phase(픽셀 마스크)
   ----------------------- */
function circleTest(a,b){
  const dx = a.x - b.x, dy = a.y - b.y;
  const dist2 = dx*dx + dy*dy;
  const r = a.radius + b.radius;
  return dist2 <= r*r;
}

function pixelOverlap(a,b){
  // a, b are Piece objects
  const ax = a.rectLeft(), ay = a.rectTop();
  const bx = b.rectLeft(), by = b.rectTop();
  const left = Math.max(ax, bx), right = Math.min(ax + a.w, bx + b.w);
  const top = Math.max(ay, by), bottom = Math.min(ay + a.h, by + b.h);
  if (right <= left || bottom <= top) return false;
  const aw = a.w, bw = b.w;
  for(let yy = top; yy < bottom; yy++){
    for(let xx = left; xx < right; xx++){
      const axi = xx - ax, ayi = yy - ay;
      const bxi = xx - bx, byi = yy - by;
      const aIdx = ayi * aw + axi;
      const bIdx = byi * bw + bxi;
      if (a.mask[aIdx] && b.mask[bIdx]) return true;
    }
  }
  return false;
}

/* -----------------------
   fight 규칙
   ----------------------- */
function fight(a,b){
  if(a.kind === b.kind) return;
  const aWins = (a.kind === "가위" && b.kind === "보") ||
                (a.kind === "바위" && b.kind === "가위") ||
                (a.kind === "보"   && b.kind === "바위");
  if(aWins) b.kind = a.kind;
  else a.kind = b.kind;
  a.updateImage(); b.updateImage();
}

/* -----------------------
   리소스 로드 및 초기화
   ----------------------- */
async function init(){
  // 1) 원본 이미지 로드
  const loaded = {};
  for(const k of Object.keys(IMAGE_FILES)){
    loaded[k] = await loadImage(IMAGE_FILES[k]);
  }
  // 2) tint & scale -> canvas, mask
  for(const k of Object.keys(loaded)){
    const tinted = tintImage(loaded[k], COLORS[k], SPRITE_SIZE);
    IMAGES_CANVAS[k] = tinted;
    MASKS[k] = makeMask(tinted);
  }

  // 3) 조각 생성
  const pieces = [];
  for(const kind of Object.keys(INITIAL_COUNT)){
    for(let i=0;i<INITIAL_COUNT[kind];i++){
      pieces.push(new Piece(kind));
    }
  }

  return pieces;
}

/* -----------------------
   메인 루프
   ----------------------- */
let pieces = [];
let running = true;
let winnerDisplayed = false;

init().then(res => {
  pieces = res;
  // loop with fixed timestep
  let last = performance.now();
  let acc = 0;
  const step = 1000 / FPS;
  function frame(now){
    if(!running) return;
    acc += now - last;
    last = now;
    while(acc >= step){
      update();
      acc -= step;
    }
    render();
    if(running) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}).catch(err=>{
  console.error('이미지 로드 실패', err);
  ctx.fillStyle = '#000';
  ctx.fillText('이미지 로드 실패: 콘솔 확인', 20, 20);
});

/* -----------------------
   update / render
   ----------------------- */
function update(){
  // move
  for(const p of pieces) p.move();

  // collision: O(n^2) with broad-phase
  const n = pieces.length;
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const a = pieces[i], b = pieces[j];
      if(!circleTest(a,b)) continue;
      if(pixelOverlap(a,b)){
        fight(a,b);
      }
    }
  }

  // winner check
  const kinds = new Set(pieces.map(p=>p.kind));
  if(kinds.size === 1 && !winnerDisplayed){
    showWinner([...kinds][0]);
  }
}

function render(){
  // background
  ctx.fillStyle = `rgb(${BG[0]},${BG[1]},${BG[2]})`;
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // draw pieces
  for(const p of pieces) p.draw(ctx);
}

/* -----------------------
   Winner overlay
   ----------------------- */
function showWinner(kind){
  winnerDisplayed = true;
  running = false; // stop loop
  // draw final frame with overlay
  ctx.fillStyle = `rgba(0,0,0,0.25)`;
  ctx.fillRect(0,0,WIDTH,HEIGHT);
  // message
  const msg = `${kind} 우승!`;
  ctx.font = 'bold 60px "Malgun Gothic","Apple SD Gothic Neo","Nanum Gothic", sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // stroke for readability
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.strokeText(msg, WIDTH/2, HEIGHT/2);
  ctx.fillStyle = '#111';
  ctx.fillText(msg, WIDTH/2, HEIGHT/2);
  // keep displayed
}

/* -----------------------
   놓을 수 있는 개선점 / 팁
   -----------------------
   - 픽셀 마스크 충돌은 무거울 수 있으므로 pieces 수를 줄이거나
     추가로 bounding-box 거리 필터(이미 있음)로 더 최적화하세요.
   - 이미지는 투명 PNG 권장(배경 흰색이면 투명 처리 필요).
   - 한글 폰트는 브라우저 기본 폰트를 사용합니다. Windows에서 맑은 고딕이 자동 적용됩니다.
*/
</script>
</body>
</html>
