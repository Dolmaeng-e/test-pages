<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>가위바위보 시뮬레이션</title>
<style>
  html,body { height:100%; margin:0; font-family: "Malgun Gothic","Apple SD Gothic Neo","Nanum Gothic", sans-serif; background:#f5f5f5; }
  .wrap { position:relative; display:flex; flex-direction:column; align-items:center; padding:12px; }
  h1 { margin:6px 0 12px; font-size:20px; color:#222; }
  canvas { background: rgb(200,185,225); border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  #winnerBtn {
    position:absolute;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    font-size:20px; padding:10px 20px;
    border:none; border-radius:6px;
    background:#556BFF; color:white; cursor:pointer;
    display:none; z-index:10;
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>가위바위보 시뮬레이션</h1>
  <canvas id="c" width="900" height="700"></canvas>
  <button id="winnerBtn">다시하기</button>
</div>

<script>
/* -----------------------
   설정
----------------------- */
const CANVAS = document.getElementById('c');
const ctx = CANVAS.getContext('2d');
const WIDTH = CANVAS.width, HEIGHT = CANVAS.height;
const FPS = 30;
const BG = [200,185,225]; // 배경색
const SPRITE_SIZE = 35;   // 조각 크기
const INITIAL_COUNT = { "가위":5, "바위":5, "보":5 };

/* 이미지 파일 경로 (같은 폴더) */
const IMAGE_FILES = { "가위":"scissors.png", "바위":"rock.png", "보":"paper.png" };

/* -----------------------
   유틸: 이미지 로드 + 색칠(tint) + 마스크 생성
----------------------- */
function loadImage(src){ return new Promise((res, rej)=>{
  const img = new Image();
  img.onload = ()=>res(img);
  img.onerror = (e)=>rej(e);
  img.src = src;
});}

// tint: 이미지 알파 보존하면서 색으로 채우기
function tintImage(img, colorStr, size){
  const oc = document.createElement('canvas');
  oc.width = size; oc.height = size;
  const octx = oc.getContext('2d');
  octx.clearRect(0,0,size,size);
  octx.drawImage(img, 0, 0, size, size);
  octx.globalCompositeOperation = 'source-in';
  octx.fillStyle = colorStr;
  octx.fillRect(0,0,size,size);
  octx.globalCompositeOperation = 'source-over';
  return oc;
}

// mask: Uint8Array of 0/1 by pixel alpha threshold
function makeMask(canvas){
  const w = canvas.width, h = canvas.height;
  const data = canvas.getContext('2d').getImageData(0,0,w,h).data;
  const mask = new Uint8Array(w*h);
  for(let i=0, p=0;i<w*h;i++, p+=4){
    mask[i] = data[p+3] > 128 ? 1 : 0;
  }
  return {mask, w, h};
}

/* -----------------------
   시뮬 데이터
----------------------- */
const COLORS = { "가위": 'rgb(255,100,100)', "바위": 'rgb(100,255,100)', "보": 'rgb(100,100,255)' };
let IMAGES_CANVAS = {}; 
let MASKS = {};         

/* -----------------------
   Piece 클래스
----------------------- */
class Piece {
  constructor(kind){
    this.kind = kind;
    this.x = Math.random()*(WIDTH-40)+20;
    this.y = Math.random()*(HEIGHT-40)+20;
    this.dx = [ -4, -2, 2, 4 ][Math.floor(Math.random()*4)];
    this.dy = [ -4, -2, 2, 4 ][Math.floor(Math.random()*4)];
    this.updateImage();
  }
  updateImage(){
    this.imgCanvas = IMAGES_CANVAS[this.kind];
    const m = MASKS[this.kind];
    this.mask = m.mask;
    this.w = m.w; this.h = m.h;
    this.rectLeft = () => Math.round(this.x - this.w/2);
    this.rectTop = () => Math.round(this.y - this.h/2);
    this.radius = Math.max(this.w,this.h)/2 * 0.9;
  }
  move(){
    this.x += this.dx; this.y += this.dy;
    if(this.x - this.w/2 < 0){ this.x = this.w/2; this.dx *= -1; }
    if(this.x + this.w/2 > WIDTH){ this.x = WIDTH - this.w/2; this.dx *= -1; }
    if(this.y - this.h/2 < 0){ this.y = this.h/2; this.dy *= -1; }
    if(this.y + this.h/2 > HEIGHT){ this.y = HEIGHT - this.h/2; this.dy *= -1; }
  }
  draw(ctx){
    ctx.drawImage(this.imgCanvas, this.rectLeft(), this.rectTop());
  }
}

/* -----------------------
   충돌: broad-phase(원) + narrow-phase(픽셀 마스크)
----------------------- */
function circleTest(a,b){
  const dx = a.x - b.x, dy = a.y - b.y;
  const dist2 = dx*dx + dy*dy;
  const r = a.radius + b.radius;
  return dist2 <= r*r;
}

function pixelOverlap(a,b){
  const ax = a.rectLeft(), ay = a.rectTop();
  const bx = b.rectLeft(), by = b.rectTop();
  const left = Math.max(ax, bx), right = Math.min(ax + a.w, bx + b.w);
  const top = Math.max(ay, by), bottom = Math.min(ay + a.h, by + b.h);
  if (right <= left || bottom <= top) return false;
  const aw = a.w, bw = b.w;
  for(let yy = top; yy < bottom; yy++){
    for(let xx = left; xx < right; xx++){
      const axi = xx - ax, ayi = yy - ay;
      const bxi = xx - bx, byi = yy - by;
      const aIdx = ayi * aw + axi;
      const bIdx = byi * bw + bxi;
      if (a.mask[aIdx] && b.mask[bIdx]) return true;
    }
  }
  return false;
}

/* -----------------------
   fight 규칙
----------------------- */
function fight(a,b){
  if(a.kind === b.kind) return;
  const aWins = (a.kind === "가위" && b.kind === "보") ||
                (a.kind === "바위" && b.kind === "가위") ||
                (a.kind === "보"   && b.kind === "바위");
  if(aWins) b.kind = a.kind;
  else a.kind = b.kind;
  a.updateImage(); b.updateImage();
}

/* -----------------------
   리소스 로드 및 초기화
----------------------- */
async function init(){
  const loaded = {};
  for(const k of Object.keys(IMAGE_FILES)){
    loaded[k] = await loadImage(IMAGE_FILES[k]);
  }
  for(const k of Object.keys(loaded)){
    const tinted = tintImage(loaded[k], COLORS[k], SPRITE_SIZE);
    IMAGES_CANVAS[k] = tinted;
    MASKS[k] = makeMask(tinted);
  }

  const pieces = [];
  for(const kind of Object.keys(INITIAL_COUNT)){
    for(let i=0;i<INITIAL_COUNT[kind];i++){
      pieces.push(new Piece(kind));
    }
  }

  return pieces;
}

/* -----------------------
   메인 루프
----------------------- */
let pieces = [];
let running = true;
let winnerDisplayed = false;

init().then(res => {
  pieces = res;
  let last = performance.now();
  let acc = 0;
  const step = 1000 / FPS;
  function frame(now){
    if(!running) return;
    acc += now - last;
    last = now;
    while(acc >= step){
      update();
      acc -= step;
    }
    render();
    if(running) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}).catch(err=>{
  console.error('이미지 로드 실패', err);
  ctx.fillStyle = '#000';
  ctx.fillText('이미지 로드 실패: 콘솔 확인', 20, 20);
});

/* -----------------------
   update / render
----------------------- */
function update(){
  for(const p of pieces) p.move();

  const n = pieces.length;
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const a = pieces[i], b = pieces[j];
      if(!circleTest(a,b)) continue;
      if(pixelOverlap(a,b)){
        fight(a,b);
      }
    }
  }

  const kinds = new Set(pieces.map(p=>p.kind));
  if(kinds.size === 1 && !winnerDisplayed){
    showWinner([...kinds][0]);
  }
}

function render(){
  ctx.fillStyle = `rgb(${BG[0]},${BG[1]},${BG[2]})`;
  ctx.fillRect(0,0,WIDTH,HEIGHT);
  for(const p of pieces) p.draw(ctx);
}

/* -----------------------
   Winner overlay + 중앙 버튼
----------------------- */
function showWinner(kind){
  winnerDisplayed = true;
  running = false;

  // 반투명 오버레이
  ctx.fillStyle = `rgba(0,0,0,0.25)`;
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // 승리 메시지
  const msg = `${kind} 우승!`;
  ctx.font = 'bold 60px "Malgun Gothic","Apple SD Gothic Neo","Nanum Gothic", sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.strokeText(msg, WIDTH/2, HEIGHT/2);
  ctx.fillStyle = '#111';
  ctx.fillText(msg, WIDTH/2, HEIGHT/2);

  // 버튼 표시
  document.getElementById('winnerBtn').style.display = 'block';
}

// 버튼 클릭 이벤트
document.getElementById('winnerBtn').addEventListener('click',()=>{ location.reload(); });

</script>
</body>
</html>
